{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"autocrop Perfect for profile picture processing for your website or batch work for ID cards, autocrop will output images centered around the biggest face detected. Use From the command line: usage : [ - h ] [ - o OUTPUT ] [ - i INPUT ] [ - w WIDTH ] [ - H HEIGHT ] [ - v ] Automatically crops faces from batches of pictures optional arguments : - h , -- help Show this help message and exit - o , -- output , - p , -- path Folder where cropped images will be placed . Default : current working directory - r , -- reject Folder where images without detected faces will be placed . Default : same as output directory - i , -- input Folder where images to crop are located . Default : current working directory - w , -- width Width of cropped files in px . Default = 500 - H , -- height Height of cropped files in px . Default = 500 -- facePercent Percentage of Face height to image height ( zoom factor ) -- padUp Padding up value compared to padDown . Default = 50 -- padDown Padding down value compared to padDown . Default = 50 -- padLeft Padding left value compared to padRight . Default = 50 -- padRight Padding right value compared to padLeft . Default = 50 - v , -- version Show program ' s version number and exit Examples Crop every image in the pics folder, resize them to 400 px squares, and output them in the crop directory: autocrop -i pics -o crop -w 400 -H 400 . Images where a face can't be detected will be left in crop . Same as above, but output the images with undetected faces to the reject folder: autocrop -i pics -o crop -r nofaces -w 400 -H 400 . Same as the first example, but add more padding at the bottom: autocrop -i pics -o crop -w 400 -H 400 --facePercent 50 --padUp 20 --padDown 50 . If no output folder is added, asks for confirmation and destructively crops images in-place. Supported file types The following file types are supported: EPS files ( .eps ) GIF files ( .gif ) (only the first frame of an animated GIF is used) JPEG 2000 files ( .j2k , .j2p , .jp2 , .jpx ) JPEG files ( .jpeg , .jpg , .jpe ) LabEye IM files ( .im ) macOS ICNS files ( .icns ) Microsoft Paint bitmap files ( .msp ) PCX files ( .pcx ) Portable Network Graphics ( .png ) Portable Pixmap files ( .pbm , .pgm , .ppm ) SGI files ( .sgi ) SPIDER files ( .spi ) TGA files ( .tga ) TIFF files ( .tif , .tiff ) WebP ( .webp ) Windows bitmap files ( .bmp , .dib ) Windows ICO files ( .ico ) X bitmap files ( .xbm ) Installation Simple! In your command line, type: pip install autocrop Gotchas Autocrop uses OpenCV to perform face detection, which is installed through binary wheels . If you already have OpenCV 3+ installed, you may wish to uninstall the additional OpenCV installation: pip uninstall opencv-python . Installing directly In some cases, you may wish the package directly, instead of through PyPI : cd ~ git clone https : // github . com / leblancfg / autocrop cd autocrop pip install . conda Development of a conda-forge package for the Anaconda Python distribution is also currently slated for development. Please leave feedback on issue #7 if you are insterested in helping out. Requirements Best practice for your projects is of course to use virtual environments . At the very least, you will need to have pip installed . Autocrop is currently being tested on: * Python: - 2.7 - 3.4 - 3.5 - 3.6 * OS: - Linux - macOS - Windows More Info Check out: * http://docs.opencv.org/master/d7/d8b/tutorial_py_face_detection.html#gsc.tab=0 * http://docs.opencv.org/master/d5/daf/tutorial_py_histogram_equalization.html#gsc.tab=0 Adapted from: * http://photo.stackexchange.com/questions/60411/how-can-i-batch-crop-based-on-face-location Contributing Although autocrop is essentially a CLI wrapper around a single OpenCV function, it is actively developed. It has active users throughout the world. If you would like to contribute, please consult the contribution docs .","title":"Home"},{"location":"#autocrop","text":"Perfect for profile picture processing for your website or batch work for ID cards, autocrop will output images centered around the biggest face detected.","title":"autocrop"},{"location":"#use","text":"From the command line: usage : [ - h ] [ - o OUTPUT ] [ - i INPUT ] [ - w WIDTH ] [ - H HEIGHT ] [ - v ] Automatically crops faces from batches of pictures optional arguments : - h , -- help Show this help message and exit - o , -- output , - p , -- path Folder where cropped images will be placed . Default : current working directory - r , -- reject Folder where images without detected faces will be placed . Default : same as output directory - i , -- input Folder where images to crop are located . Default : current working directory - w , -- width Width of cropped files in px . Default = 500 - H , -- height Height of cropped files in px . Default = 500 -- facePercent Percentage of Face height to image height ( zoom factor ) -- padUp Padding up value compared to padDown . Default = 50 -- padDown Padding down value compared to padDown . Default = 50 -- padLeft Padding left value compared to padRight . Default = 50 -- padRight Padding right value compared to padLeft . Default = 50 - v , -- version Show program ' s version number and exit","title":"Use"},{"location":"#examples","text":"Crop every image in the pics folder, resize them to 400 px squares, and output them in the crop directory: autocrop -i pics -o crop -w 400 -H 400 . Images where a face can't be detected will be left in crop . Same as above, but output the images with undetected faces to the reject folder: autocrop -i pics -o crop -r nofaces -w 400 -H 400 . Same as the first example, but add more padding at the bottom: autocrop -i pics -o crop -w 400 -H 400 --facePercent 50 --padUp 20 --padDown 50 . If no output folder is added, asks for confirmation and destructively crops images in-place.","title":"Examples"},{"location":"#supported-file-types","text":"The following file types are supported: EPS files ( .eps ) GIF files ( .gif ) (only the first frame of an animated GIF is used) JPEG 2000 files ( .j2k , .j2p , .jp2 , .jpx ) JPEG files ( .jpeg , .jpg , .jpe ) LabEye IM files ( .im ) macOS ICNS files ( .icns ) Microsoft Paint bitmap files ( .msp ) PCX files ( .pcx ) Portable Network Graphics ( .png ) Portable Pixmap files ( .pbm , .pgm , .ppm ) SGI files ( .sgi ) SPIDER files ( .spi ) TGA files ( .tga ) TIFF files ( .tif , .tiff ) WebP ( .webp ) Windows bitmap files ( .bmp , .dib ) Windows ICO files ( .ico ) X bitmap files ( .xbm )","title":"Supported file types"},{"location":"#installation","text":"Simple! In your command line, type: pip install autocrop","title":"Installation"},{"location":"#gotchas","text":"Autocrop uses OpenCV to perform face detection, which is installed through binary wheels . If you already have OpenCV 3+ installed, you may wish to uninstall the additional OpenCV installation: pip uninstall opencv-python .","title":"Gotchas"},{"location":"#installing-directly","text":"In some cases, you may wish the package directly, instead of through PyPI : cd ~ git clone https : // github . com / leblancfg / autocrop cd autocrop pip install .","title":"Installing directly"},{"location":"#conda","text":"Development of a conda-forge package for the Anaconda Python distribution is also currently slated for development. Please leave feedback on issue #7 if you are insterested in helping out.","title":"conda"},{"location":"#requirements","text":"Best practice for your projects is of course to use virtual environments . At the very least, you will need to have pip installed . Autocrop is currently being tested on: * Python: - 2.7 - 3.4 - 3.5 - 3.6 * OS: - Linux - macOS - Windows","title":"Requirements"},{"location":"#more-info","text":"Check out: * http://docs.opencv.org/master/d7/d8b/tutorial_py_face_detection.html#gsc.tab=0 * http://docs.opencv.org/master/d5/daf/tutorial_py_histogram_equalization.html#gsc.tab=0 Adapted from: * http://photo.stackexchange.com/questions/60411/how-can-i-batch-crop-based-on-face-location","title":"More Info"},{"location":"#contributing","text":"Although autocrop is essentially a CLI wrapper around a single OpenCV function, it is actively developed. It has active users throughout the world. If you would like to contribute, please consult the contribution docs .","title":"Contributing"},{"location":"CONTRIBUTING/","text":"Contributing All contributions, bug reports, bug fixes, documentation improvements, enhancements, and ideas are welcome. Please follow these steps: Fork the autocrop repository to your personal GitHub account and clone it locally Install the development setup (see section below) Branch off of master for every change you want to make Develop changes on your branch Test your changes (see section below) Modify the tests and documentation as necessary When your changes are ready, make a pull request to the upstream autocrop repository Development Setup This project works with virtualenv . To start things off, run: $ python3 -m venv env $ source env/bin/activate Then, run: $ pip install -U setuptools $ pip install -r requirements-test.txt $ pip install -e . You can then run autocrop like so: $ autocrop As long as the virtual environment has been activated, this will command will use the files in your local Git checkout. This makes it super easy to work on the code and test your changes. To set up your virtual environment again in future, just run: $ source env/bin/activate Tests Pull requests are tested using continuous integration (CI) which will green-light changes. Specifically, we: Use flake8 for coding style tests Run a test suite using pytest You can run the tests locally, like so: $ make check Contact If you have any questions, please email me at leblancfg@gmail.com .","title":"Contributing"},{"location":"CONTRIBUTING/#contributing","text":"All contributions, bug reports, bug fixes, documentation improvements, enhancements, and ideas are welcome. Please follow these steps: Fork the autocrop repository to your personal GitHub account and clone it locally Install the development setup (see section below) Branch off of master for every change you want to make Develop changes on your branch Test your changes (see section below) Modify the tests and documentation as necessary When your changes are ready, make a pull request to the upstream autocrop repository","title":"Contributing"},{"location":"CONTRIBUTING/#development-setup","text":"This project works with virtualenv . To start things off, run: $ python3 -m venv env $ source env/bin/activate Then, run: $ pip install -U setuptools $ pip install -r requirements-test.txt $ pip install -e . You can then run autocrop like so: $ autocrop As long as the virtual environment has been activated, this will command will use the files in your local Git checkout. This makes it super easy to work on the code and test your changes. To set up your virtual environment again in future, just run: $ source env/bin/activate","title":"Development Setup"},{"location":"CONTRIBUTING/#tests","text":"Pull requests are tested using continuous integration (CI) which will green-light changes. Specifically, we: Use flake8 for coding style tests Run a test suite using pytest You can run the tests locally, like so: $ make check","title":"Tests"},{"location":"CONTRIBUTING/#contact","text":"If you have any questions, please email me at leblancfg@gmail.com .","title":"Contact"},{"location":"changelog/","text":"Autocrop changelog 0.3.2 Changes Autocrop now prints the filename of images where face detection failed Internal refactoring and more tests 0.3.1 Changes Add -r , --reject flag to specify directory where the images that autocrop couldn't find a face in are directed to. Instead of having the target files copied then cropped, they are instead cropped and saved to their respective target folder. 0.3.0 Changes Added support for padding ( padLeft , etc.) in the CLI. Bugfix Fixed warp on crop for -w and -h values 0.2.0 Changes Add -o , --output flag to specify directory where cropped images are to be dumped. Error out if output folder set to current directory, i.e. -o . If directory doesn't exist yet, create it. If no face can be found in an image in batch, it is still copied over to -o folder. If no output folder is added, ask for confirmation ([Y]/n), and destructively crop images in-place. Use -i , --input flags as synonyms for -p or --path : symmetrical in meaning to \"output\". Is now standard nomenclature in documentation. --input or --path flag is now optional. Standard behaviour without input folder is to non-recursively process all images in immediate folder, i.e. -p . as currently implemented. Breaks Removed all mentions of the hard-coded 'bkp' and 'crop' folders Calling autocrop without specifying an input path, i.e. autocrop does not look for the 'images' folder anymore.","title":"Changelog"},{"location":"changelog/#autocrop-changelog","text":"","title":"Autocrop changelog"},{"location":"changelog/#032","text":"","title":"0.3.2"},{"location":"changelog/#changes","text":"Autocrop now prints the filename of images where face detection failed Internal refactoring and more tests","title":"Changes"},{"location":"changelog/#031","text":"","title":"0.3.1"},{"location":"changelog/#changes_1","text":"Add -r , --reject flag to specify directory where the images that autocrop couldn't find a face in are directed to. Instead of having the target files copied then cropped, they are instead cropped and saved to their respective target folder.","title":"Changes"},{"location":"changelog/#030","text":"","title":"0.3.0"},{"location":"changelog/#changes_2","text":"Added support for padding ( padLeft , etc.) in the CLI.","title":"Changes"},{"location":"changelog/#bugfix","text":"Fixed warp on crop for -w and -h values","title":"Bugfix"},{"location":"changelog/#020","text":"","title":"0.2.0"},{"location":"changelog/#changes_3","text":"Add -o , --output flag to specify directory where cropped images are to be dumped. Error out if output folder set to current directory, i.e. -o . If directory doesn't exist yet, create it. If no face can be found in an image in batch, it is still copied over to -o folder. If no output folder is added, ask for confirmation ([Y]/n), and destructively crop images in-place. Use -i , --input flags as synonyms for -p or --path : symmetrical in meaning to \"output\". Is now standard nomenclature in documentation. --input or --path flag is now optional. Standard behaviour without input folder is to non-recursively process all images in immediate folder, i.e. -p . as currently implemented.","title":"Changes"},{"location":"changelog/#breaks","text":"Removed all mentions of the hard-coded 'bkp' and 'crop' folders Calling autocrop without specifying an input path, i.e. autocrop does not look for the 'images' folder anymore.","title":"Breaks"},{"location":"reference/autocrop/","text":"Module autocrop View Source # -*- coding: utf-8 -*- import os import sys from .autocrop import cli # Inject vendored directory into system path. v_path = os . path . abspath ( os . path . sep . join ([ os . path . dirname ( os . path . realpath ( __file__ )), \"vendor\" ]) ) sys . path . insert ( 0 , v_path ) # Inject patched directory into system path. v_path = os . path . abspath ( os . path . sep . join ([ os . path . dirname ( os . path . realpath ( __file__ )), \"patched\" ]) ) sys . path . insert ( 0 , v_path ) if __name__ == \"__main__\" : cli () Sub-modules autocrop.autocrop autocrop.constants","title":"Index"},{"location":"reference/autocrop/#module-autocrop","text":"View Source # -*- coding: utf-8 -*- import os import sys from .autocrop import cli # Inject vendored directory into system path. v_path = os . path . abspath ( os . path . sep . join ([ os . path . dirname ( os . path . realpath ( __file__ )), \"vendor\" ]) ) sys . path . insert ( 0 , v_path ) # Inject patched directory into system path. v_path = os . path . abspath ( os . path . sep . join ([ os . path . dirname ( os . path . realpath ( __file__ )), \"patched\" ]) ) sys . path . insert ( 0 , v_path ) if __name__ == \"__main__\" : cli ()","title":"Module autocrop"},{"location":"reference/autocrop/#sub-modules","text":"autocrop.autocrop autocrop.constants","title":"Sub-modules"},{"location":"reference/autocrop/autocrop/","text":"Module autocrop.autocrop View Source # -*- coding: utf-8 -*- from __future__ import print_function import argparse import cv2 import io import numpy as np import os import shutil import sys from PIL import Image from .__version__ import __version__ from .constants import ( FIXEXP , MINFACE , GAMMA_THRES , GAMMA , QUESTION_OVERWRITE , CV2_FILETYPES , PILLOW_FILETYPES , CASCFILE , ) COMBINED_FILETYPES = CV2_FILETYPES + PILLOW_FILETYPES INPUT_FILETYPES = COMBINED_FILETYPES + [ s . upper () for s in COMBINED_FILETYPES ] # Load XML Resource d = os . path . dirname ( sys . modules [ \"autocrop\" ] . __file__ ) cascPath = os . path . join ( d , CASCFILE ) # Load custom exception to catch a certain failure type class ImageReadError ( BaseException ): pass # Define simple gamma correction fn def gamma ( img , correction ): img = cv2 . pow ( img / 255.0 , correction ) return np . uint8 ( img * 255 ) def crop_positions ( imgh , imgw , x , y , w , h , fheight , fwidth , facePercent , padUp , padDown , padLeft , padRight , ): # Check padding values padUp = 50 if ( padUp is False or padUp < 0 ) else padUp padDown = 50 if ( padDown is False or padDown < 0 ) else padDown padLeft = 50 if ( padLeft is False or padLeft < 0 ) else padLeft padRight = 50 if ( padRight is False or padRight < 0 ) else padRight # enfoce face percent facePercent = 100 if facePercent > 100 else facePercent facePercent = 50 if facePercent <= 0 else facePercent # Adjust output height based on Face percent height_crop = h * 100.0 / facePercent # Ensure height is within boundaries height_crop = imgh if height_crop > imgh else height_crop aspect_ratio = float ( fwidth ) / float ( fheight ) # Calculate width based on aspect ratio width_crop = aspect_ratio * float ( height_crop ) # Calculate padding by centering face xpad = ( width_crop - w ) / 2 ypad = ( height_crop - h ) / 2 # Calc. positions of crop h1 = float ( x - ( xpad * padLeft / ( padLeft + padRight ))) h2 = float ( x + w + ( xpad * padRight / ( padLeft + padRight ))) v1 = float ( y - ( ypad * padUp / ( padUp + padDown ))) v2 = float ( y + h + ( ypad * padDown / ( padUp + padDown ))) # Move crop inside photo boundaries while h1 < 0 : h1 = h1 + 1 h2 = h2 + 1 while v1 < 0 : v1 = v1 + 1 v2 = v2 + 1 while v2 > imgh : v2 = v2 - 1 h2 = h2 - 1 * aspect_ratio while h2 > imgw : h2 = h2 - 1 v2 = v2 - 1 / aspect_ratio return [ int ( v1 ), int ( v2 ), int ( h1 ), int ( h2 )] def crop ( image , fheight = 500 , fwidth = 500 , facePercent = 50 , padUp = False , padDown = False , padLeft = False , padRight = False , ): \"\"\"Given a ndarray image with a face, returns cropped array. Arguments: - image, the numpy array of the image to be processed. - fwidth, the final width (px) of the cropped img. Default: 500 - fheight, the final height (px) of the cropped img. Default: 500 - facePercent, percentage of face height to image height. Default: 50 - padUp, Padding from top - padDown, Padding to bottom - padLeft, Padding from left - padRight, Padding to right Returns: - image, a cropped numpy array ndarray, int, int -> ndarray \"\"\" # Some grayscale color profiles can throw errors, catch them try : gray = cv2 . cvtColor ( image , cv2 . COLOR_BGR2GRAY ) except cv2 . error : gray = image # Scale the image try : height , width = image . shape [: 2 ] except AttributeError : raise ImageReadError minface = int ( np . sqrt ( height ** 2 + width ** 2 ) / MINFACE ) # Create the haar cascade faceCascade = cv2 . CascadeClassifier ( cascPath ) # ====== Detect faces in the image ====== faces = faceCascade . detectMultiScale ( gray , scaleFactor = 1.1 , minNeighbors = 5 , minSize = ( minface , minface ), flags = cv2 . CASCADE_FIND_BIGGEST_OBJECT | cv2 . CASCADE_DO_ROUGH_SEARCH , ) # Handle no faces if len ( faces ) == 0 : return None # Make padding from biggest face found x , y , w , h = faces [ - 1 ] pos = crop_positions ( height , width , x , y , w , h , fheight , fwidth , facePercent , padUp , padDown , padLeft , padRight , ) # Actual cropping image = image [ pos [ 0 ]: pos [ 1 ], pos [ 2 ]: pos [ 3 ]] # Resize image = cv2 . resize ( image , ( fwidth , fheight ), interpolation = cv2 . INTER_AREA ) # ====== Dealing with underexposition ====== if FIXEXP : # Check if under-exposed uexp = cv2 . calcHist ([ gray ], [ 0 ], None , [ 256 ], [ 0 , 256 ]) if sum ( uexp [ - 26 :]) < GAMMA_THRES * sum ( uexp ): image = gamma ( image , GAMMA ) return image def open_file ( input_filename ): \"\"\"Given a filename, returns a numpy array\"\"\" extension = os . path . splitext ( input_filename )[ 1 ] . lower () if extension in CV2_FILETYPES : # Try with cv2 return cv2 . imread ( input_filename ) if extension in PILLOW_FILETYPES : # Try with PIL with Image . open ( input_filename ) as img_orig : return np . asarray ( img_orig ) return None def output ( input_filename , output_filename , image ): \"\"\"Move the input file to the output location and write over it with the cropped image data.\"\"\" if input_filename != output_filename : # Move the file to the output directory shutil . move ( input_filename , output_filename ) # Encode the image as an in-memory PNG img_png = cv2 . imencode ( \".png\" , image )[ 1 ] . tostring () # Read the PNG data img_new = Image . open ( io . BytesIO ( img_png )) # Write the new image (converting the format to match the output # filename if necessary) img_new . save ( output_filename ) def reject ( input_filename , reject_filename ): \"\"\"Move the input file to the reject location.\"\"\" if input_filename != reject_filename : # Move the file to the reject directory shutil . move ( input_filename , reject_filename ) def main ( input_d , output_d , reject_d , fheight = 500 , fwidth = 500 , facePercent = 50 , padUp = False , padDown = False , padLeft = False , padRight = False , ): \"\"\"Crops folder of images to the desired height and width if a face is found If input_d == output_d or output_d is None, overwrites all files where the biggest face was found. Args: input_d (str): Directory to crop images from. output_d (str): Directory where cropped images are placed. reject_d (str): Directory where images that cannot be cropped are placed. fheight (int): Height (px) to which to crop the image. Default: 500px fwidth (int): Width (px) to which to crop the image. Default: 500px facePercent (int) : Percentage of face from height, Default: 50 Side Effects: Creates image files in output directory. str, str, (int), (int) -> None \"\"\" reject_count = 0 output_count = 0 input_files = [ os . path . join ( input_d , f ) for f in os . listdir ( input_d ) if any ( f . endswith ( t ) for t in INPUT_FILETYPES ) ] if output_d is None : output_d = input_d if reject_d is None and output_d is None : reject_d = input_d if reject_d is None : reject_d = output_d # Guard against calling the function directly input_count = len ( input_files ) assert input_count > 0 # Main loop for input_filename in input_files : basename = os . path . basename ( input_filename ) output_filename = os . path . join ( output_d , basename ) reject_filename = os . path . join ( reject_d , basename ) input_img = open_file ( input_filename ) image = None # Attempt the crop try : image = crop ( input_img , fheight , fwidth , facePercent , padUp , padDown , padLeft , padRight , ) except ImageReadError : print ( \"Read error: {}\" . format ( input_filename )) continue # Did the crop produce an invalid image? if isinstance ( image , type ( None )): reject ( input_filename , reject_filename ) print ( \"No face detected: {}\" . format ( reject_filename )) reject_count += 1 else : output ( input_filename , output_filename , image ) print ( \"Face detected: {}\" . format ( output_filename )) output_count += 1 # Stop and print status print ( \"{} input files, {} faces cropped, {} rejected\" . format ( input_count , output_count , reject_count ) ) def input_path ( p ): \"\"\"Returns path, only if input is a valid directory\"\"\" no_folder = \"Input folder does not exist\" no_images = \"Input folder does not contain any image files\" p = os . path . abspath ( p ) if not os . path . isdir ( p ): raise argparse . ArgumentTypeError ( no_folder ) filetypes = set ( os . path . splitext ( f )[ - 1 ] for f in os . listdir ( p )) if not any ( t in INPUT_FILETYPES for t in filetypes ): raise argparse . ArgumentTypeError ( no_images ) else : return p def output_path ( p ): \"\"\"Returns path, if input is a valid directory name. If directory doesn't exist, creates it.\"\"\" p = os . path . abspath ( p ) if not os . path . isdir ( p ): os . makedirs ( p ) return p def size ( i ): \"\"\"Returns valid only if input is a positive integer under 1e5\"\"\" error = \"Invalid pixel size\" try : i = int ( i ) except TypeError : raise argparse . ArgumentTypeError ( error ) if i > 0 and i < 1e5 : return i else : raise argparse . ArgumentTypeError ( error ) def compat_input ( s = \"\" ): \"\"\"Compatibility function to permit testing for Python 2 and 3\"\"\" try : return raw_input ( s ) except NameError : # Py2 raw_input() renamed to input() in Py3 return input ( s ) # lgtm[py/use-of-input] def confirmation ( question , default = True ): \"\"\"Ask a yes/no question via standard input and return the answer. If invalid input is given, the user will be asked until they acutally give valid input. Args: question(str): A question that is presented to the user. default(bool|None): The default value when enter is pressed with no value. When None, there is no default value and the query will loop. Returns: A bool indicating whether user has entered yes or no. Side Effects: Blocks program execution until valid input(y/n) is given. \"\"\" yes_list = [ \"yes\" , \"y\" ] no_list = [ \"no\" , \"n\" ] default_dict = { # default => prompt default string None : \"[y/n]\" , True : \"[Y]/n\" , False : \"y/[N]\" , } default_str = default_dict [ default ] prompt_str = \" %s %s \" % ( question , default_str ) while True : choice = compat_input ( prompt_str ) . lower () if not choice and default is not None : return default if choice in yes_list : return True if choice in no_list : return False notification_str = \"Please respond with 'y' or 'n'\" print ( notification_str ) def parse_args ( args ): help_d = { \"desc\" : \"Automatically crops faces from batches of pictures\" , \"input\" : \"\"\"Folder where images to crop are located. Default: current working directory\"\"\" , \"output\" : \"\"\"Folder where cropped images will be moved to. Default: current working directory, meaning images are cropped in place.\"\"\" , \"reject\" : \"\"\"Folder where images that could not be cropped will be moved to. Default: current working directory, meaning images that are not cropped will be left in place.\"\"\" , \"width\" : \"Width of cropped files in px. Default=500\" , \"height\" : \"Height of cropped files in px. Default=500\" , \"y\" : \"Bypass any confirmation prompts\" , \"facePercent\" : \"Percentage of face to image height\" , \"padUp\" : \"Add padding up to face cropped\" , \"padDown\" : \"Add padding down to face cropped\" , \"padLeft\" : \"Add padding left to face cropped\" , \"padRight\" : \"Add padding right to face cropped\" , } parser = argparse . ArgumentParser ( description = help_d [ \"desc\" ]) parser . add_argument ( \"-i\" , \"--input\" , default = \".\" , type = input_path , help = help_d [ \"input\" ] ) parser . add_argument ( \"-o\" , \"--output\" , \"-p\" , \"--path\" , type = output_path , default = None , help = help_d [ \"output\" ], ) parser . add_argument ( \"-r\" , \"--reject\" , type = output_path , default = None , help = help_d [ \"reject\" ] ) parser . add_argument ( \"-w\" , \"--width\" , type = size , default = 500 , help = help_d [ \"width\" ] ) parser . add_argument ( \"-H\" , \"--height\" , type = size , default = 500 , help = help_d [ \"height\" ] ) parser . add_argument ( \"-v\" , \"--version\" , action = \"version\" , version = \" %(prog)s version {}\" . format ( __version__ ), ) parser . add_argument ( \"--no-confirm\" , action = \"store_true\" , help = help_d [ \"y\" ]) parser . add_argument ( \"--padUp\" , type = size , default = False , help = help_d [ \"padUp\" ] ) parser . add_argument ( \"--padDown\" , type = size , default = False , help = help_d [ \"padDown\" ] ) parser . add_argument ( \"--padLeft\" , type = size , default = False , help = help_d [ \"padLeft\" ] ) parser . add_argument ( \"--padRight\" , type = size , default = False , help = help_d [ \"padRight\" ] ) parser . add_argument ( \"--facePercent\" , type = size , default = 50 , help = help_d [ \"facePercent\" ] ) return parser . parse_args () def cli (): args = parse_args ( sys . argv [ 1 :]) if not args . no_confirm : if args . output is None or args . input == args . output : if not confirmation ( QUESTION_OVERWRITE ): sys . exit () if args . input == args . output : args . output = None print ( \"Processing images in folder:\" , args . input ) main ( args . input , args . output , args . reject , args . height , args . width , args . facePercent , args . padUp , args . padDown , args . padLeft , args . padRight , ) Functions cli def ( ) View Source def cli () : args = parse_args ( sys . argv [ 1 :] ) if not args . no_confirm : if args . output is None or args . input == args . output : if not confirmation ( QUESTION_OVERWRITE ) : sys . exit () if args . input == args . output : args . output = None print ( \" Processing images in folder: \" , args . input ) main ( args . input , args . output , args . reject , args . height , args . width , args . facePercent , args . padUp , args . padDown , args . padLeft , args . padRight , ) compat_input def ( s = '' ) Compatibility function to permit testing for Python 2 and 3 View Source def compat_input ( s = \"\" ) : \"\"\" Compatibility function to permit testing for Python 2 and 3 \"\"\" try : return raw_input ( s ) except NameError : # Py2 raw_input () renamed to input () in Py3 return input ( s ) # lgtm [ py / use - of - input ] confirmation def ( question , default = True ) Ask a yes/no question via standard input and return the answer. If invalid input is given, the user will be asked until they acutally give valid input. Args: question(str): A question that is presented to the user. default(bool|None): The default value when enter is pressed with no value. When None, there is no default value and the query will loop. Returns: A bool indicating whether user has entered yes or no. Side Effects: Blocks program execution until valid input(y/n) is given. View Source def confirmation ( question , default = True ) : \"\"\" Ask a yes/no question via standard input and return the answer. If invalid input is given , the user will be asked until they acutally give valid input . Args : question ( str ) : A question that is presented to the user . default ( bool | None ) : The default value when enter is pressed with no value . When None , there is no default value and the query will loop . Returns : A bool indicating whether user has entered yes or no . Side Effects : Blocks program execution until valid input ( y / n ) is given . \"\"\" yes_list = [ \" yes \" , \" y \" ] no_list = [ \" no \" , \" n \" ] default_dict = { # default => prompt default string None : \" [y/n] \" , True : \" [Y]/n \" , False : \" y/[N] \" , } default_str = default_dict [ default ] prompt_str = \" %s %s \" % ( question , default_str ) while True : choice = compat_input ( prompt_str ) . lower () if not choice and default is not None : return default if choice in yes_list : return True if choice in no_list : return False notification_str = \" Please respond with 'y' or 'n' \" print ( notification_str ) crop def ( image , fheight = 500 , fwidth = 500 , facePercent = 50 , padUp = False , padDown = False , padLeft = False , padRight = False ) Given a ndarray image with a face, returns cropped array. Arguments: - image, the numpy array of the image to be processed. - fwidth, the final width (px) of the cropped img. Default: 500 - fheight, the final height (px) of the cropped img. Default: 500 - facePercent, percentage of face height to image height. Default: 50 - padUp, Padding from top - padDown, Padding to bottom - padLeft, Padding from left - padRight, Padding to right Returns: - image, a cropped numpy array ndarray, int, int -> ndarray View Source def crop ( image , fheight = 500 , fwidth = 500 , facePercent = 50 , padUp = False , padDown = False , padLeft = False , padRight = False , ) : \"\"\" Given a ndarray image with a face, returns cropped array. Arguments : - image , the numpy array of the image to be processed . - fwidth , the final width ( px ) of the cropped img . Default : 500 - fheight , the final height ( px ) of the cropped img . Default : 500 - facePercent , percentage of face height to image height . Default : 50 - padUp , Padding from top - padDown , Padding to bottom - padLeft , Padding from left - padRight , Padding to right Returns : - image , a cropped numpy array ndarray , int , int -> ndarray \"\"\" # Some grayscale color profiles can throw errors , catch them try : gray = cv2 . cvtColor ( image , cv2 . COLOR_BGR2GRAY ) except cv2 . error : gray = image # Scale the image try : height , width = image . shape [: 2 ] except AttributeError : raise ImageReadError minface = int ( np . sqrt ( height ** 2 + width ** 2 ) / MINFACE ) # Create the haar cascade faceCascade = cv2 . CascadeClassifier ( cascPath ) # ====== Detect faces in the image ====== faces = faceCascade . detectMultiScale ( gray , scaleFactor = 1 . 1 , minNeighbors = 5 , minSize = ( minface , minface ) , flags = cv2 . CASCADE_FIND_BIGGEST_OBJECT | cv2 . CASCADE_DO_ROUGH_SEARCH , ) # Handle no faces if len ( faces ) == 0 : return None # Make padding from biggest face found x , y , w , h = faces [ - 1 ] pos = crop_positions ( height , width , x , y , w , h , fheight , fwidth , facePercent , padUp , padDown , padLeft , padRight , ) # Actual cropping image = image [ pos [ 0 ]: pos [ 1 ], pos [ 2 ]: pos [ 3 ]] # Resize image = cv2 . resize ( image , ( fwidth , fheight ) , interpolation = cv2 . INTER_AREA ) # ====== Dealing with underexposition ====== if FIXEXP : # Check if under - exposed uexp = cv2 . calcHist ( [ gray ], [ 0 ], None , [ 256 ], [ 0 , 256 ] ) if sum ( uexp [ - 26 :] ) < GAMMA_THRES * sum ( uexp ) : image = gamma ( image , GAMMA ) return image crop_positions def ( imgh , imgw , x , y , w , h , fheight , fwidth , facePercent , padUp , padDown , padLeft , padRight ) View Source def crop_positions ( imgh , imgw , x , y , w , h , fheight , fwidth , facePercent , padUp , padDown , padLeft , padRight , ) : # Check padding values padUp = 50 if ( padUp is False or padUp < 0 ) else padUp padDown = 50 if ( padDown is False or padDown < 0 ) else padDown padLeft = 50 if ( padLeft is False or padLeft < 0 ) else padLeft padRight = 50 if ( padRight is False or padRight < 0 ) else padRight # enfoce face percent facePercent = 100 if facePercent > 100 else facePercent facePercent = 50 if facePercent <= 0 else facePercent # Adjust output height based on Face percent height_crop = h * 100 . 0 / facePercent # Ensure height is within boundaries height_crop = imgh if height_crop > imgh else height_crop aspect_ratio = float ( fwidth ) / float ( fheight ) # Calculate width based on aspect ratio width_crop = aspect_ratio * float ( height_crop ) # Calculate padding by centering face xpad = ( width_crop - w ) / 2 ypad = ( height_crop - h ) / 2 # Calc . positions of crop h1 = float ( x - ( xpad * padLeft / ( padLeft + padRight ))) h2 = float ( x + w + ( xpad * padRight / ( padLeft + padRight ))) v1 = float ( y - ( ypad * padUp / ( padUp + padDown ))) v2 = float ( y + h + ( ypad * padDown / ( padUp + padDown ))) # Move crop inside photo boundaries while h1 < 0 : h1 = h1 + 1 h2 = h2 + 1 while v1 < 0 : v1 = v1 + 1 v2 = v2 + 1 while v2 > imgh : v2 = v2 - 1 h2 = h2 - 1 * aspect_ratio while h2 > imgw : h2 = h2 - 1 v2 = v2 - 1 / aspect_ratio return [ int ( v1 ) , int ( v2 ) , int ( h1 ) , int ( h2 ) ] gamma def ( img , correction ) View Source def gamma ( img , correction ) : img = cv2 . pow ( img / 255 . 0 , correction ) return np . uint8 ( img * 255 ) input_path def ( p ) Returns path, only if input is a valid directory View Source def input_path ( p ) : \"\"\" Returns path, only if input is a valid directory \"\"\" no_folder = \" Input folder does not exist \" no_images = \" Input folder does not contain any image files \" p = os . path . abspath ( p ) if not os . path . isdir ( p ) : raise argparse . ArgumentTypeError ( no_folder ) filetypes = set ( os . path . splitext ( f ) [ - 1 ] for f in os . listdir ( p )) if not any ( t in INPUT_FILETYPES for t in filetypes ) : raise argparse . ArgumentTypeError ( no_images ) else : return p main def ( input_d , output_d , reject_d , fheight = 500 , fwidth = 500 , facePercent = 50 , padUp = False , padDown = False , padLeft = False , padRight = False ) Crops folder of images to the desired height and width if a face is found If input_d == output_d or output_d is None, overwrites all files where the biggest face was found. Args: input_d (str): Directory to crop images from. output_d (str): Directory where cropped images are placed. reject_d (str): Directory where images that cannot be cropped are placed. fheight (int): Height (px) to which to crop the image. Default: 500px fwidth (int): Width (px) to which to crop the image. Default: 500px facePercent (int) : Percentage of face from height, Default: 50 Side Effects: Creates image files in output directory. str, str, (int), (int) -> None View Source def main ( input_d , output_d , reject_d , fheight = 500 , fwidth = 500 , facePercent = 50 , padUp = False , padDown = False , padLeft = False , padRight = False , ) : \"\"\" Crops folder of images to the desired height and width if a face is found If input_d == output_d or output_d is None , overwrites all files where the biggest face was found . Args : input_d ( str ) : Directory to crop images from . output_d ( str ) : Directory where cropped images are placed . reject_d ( str ) : Directory where images that cannot be cropped are placed . fheight ( int ) : Height ( px ) to which to crop the image . Default : 500 px fwidth ( int ) : Width ( px ) to which to crop the image . Default : 500 px facePercent ( int ) : Percentage of face from height , Default : 50 Side Effects : Creates image files in output directory . str , str , ( int ) , ( int ) -> None \"\"\" reject_count = 0 output_count = 0 input_files = [ os . path . join ( input_d , f ) for f in os . listdir ( input_d ) if any ( f . endswith ( t ) for t in INPUT_FILETYPES ) ] if output_d is None : output_d = input_d if reject_d is None and output_d is None : reject_d = input_d if reject_d is None : reject_d = output_d # Guard against calling the function directly input_count = len ( input_files ) assert input_count > 0 # Main loop for input_filename in input_files : basename = os . path . basename ( input_filename ) output_filename = os . path . join ( output_d , basename ) reject_filename = os . path . join ( reject_d , basename ) input_img = open_file ( input_filename ) image = None # Attempt the crop try : image = crop ( input_img , fheight , fwidth , facePercent , padUp , padDown , padLeft , padRight , ) except ImageReadError : print ( \" Read error: {} \" . format ( input_filename )) continue # Did the crop produce an invalid image ? if isinstance ( image , type ( None )) : reject ( input_filename , reject_filename ) print ( \" No face detected: {} \" . format ( reject_filename )) reject_count += 1 else : output ( input_filename , output_filename , image ) print ( \" Face detected: {} \" . format ( output_filename )) output_count += 1 # Stop and print status print ( \" {} input files, {} faces cropped, {} rejected \" . format ( input_count , output_count , reject_count ) ) open_file def ( input_filename ) Given a filename, returns a numpy array View Source def open_file ( input_filename ) : \"\"\" Given a filename, returns a numpy array \"\"\" extension = os . path . splitext ( input_filename ) [ 1 ]. lower () if extension in CV2_FILETYPES : # Try with cv2 return cv2 . imread ( input_filename ) if extension in PILLOW_FILETYPES : # Try with PIL with Image . open ( input_filename ) as img_orig : return np . asarray ( img_orig ) return None output def ( input_filename , output_filename , image ) Move the input file to the output location and write over it with the cropped image data. View Source def output ( input_filename , output_filename , image ) : \"\"\" Move the input file to the output location and write over it with the cropped image data . \"\"\" if input_filename != output_filename : # Move the file to the output directory shutil . move ( input_filename , output_filename ) # Encode the image as an in - memory PNG img_png = cv2 . imencode ( \" .png \" , image ) [ 1 ]. tostring () # Read the PNG data img_new = Image . open ( io . BytesIO ( img_png )) # Write the new image ( converting the format to match the output # filename if necessary ) img_new . save ( output_filename ) output_path def ( p ) Returns path, if input is a valid directory name. If directory doesn't exist, creates it. View Source def output_path ( p ) : \"\"\" Returns path, if input is a valid directory name. If directory doesn ' t exist, creates it.\"\"\" p = os . path . abspath ( p ) if not os . path . isdir ( p ) : os . makedirs ( p ) return p parse_args def ( args ) View Source def parse_args ( args ) : help_d = { \" desc \" : \" Automatically crops faces from batches of pictures \" , \" input \" : \"\"\" Folder where images to crop are located. Default: current working directory \"\"\" , \" output \" : \"\"\" Folder where cropped images will be moved to. Default : current working directory , meaning images are cropped in place . \"\"\" , \" reject \" : \"\"\" Folder where images that could not be cropped will be moved to . Default : current working directory , meaning images that are not cropped will be left in place . \"\"\" , \" width \" : \" Width of cropped files in px. Default=500 \" , \" height \" : \" Height of cropped files in px. Default=500 \" , \" y \" : \" Bypass any confirmation prompts \" , \" facePercent \" : \" Percentage of face to image height \" , \" padUp \" : \" Add padding up to face cropped \" , \" padDown \" : \" Add padding down to face cropped \" , \" padLeft \" : \" Add padding left to face cropped \" , \" padRight \" : \" Add padding right to face cropped \" , } parser = argparse . ArgumentParser ( description = help_d [ \" desc \" ] ) parser . add_argument ( \" -i \" , \" --input \" , default = \" . \" , type = input_path , help = help_d [ \" input \" ] ) parser . add_argument ( \" -o \" , \" --output \" , \" -p \" , \" --path \" , type = output_path , default = None , help = help_d [ \" output \" ], ) parser . add_argument ( \" -r \" , \" --reject \" , type = output_path , default = None , help = help_d [ \" reject \" ] ) parser . add_argument ( \" -w \" , \" --width \" , type = size , default = 500 , help = help_d [ \" width \" ] ) parser . add_argument ( \" -H \" , \" --height \" , type = size , default = 500 , help = help_d [ \" height \" ] ) parser . add_argument ( \" -v \" , \" --version \" , action = \" version \" , version = \" %(prog)s version {} \" . format ( __version__ ) , ) parser . add_argument ( \" --no-confirm \" , action = \" store_true \" , help = help_d [ \" y \" ] ) parser . add_argument ( \" --padUp \" , type = size , default = False , help = help_d [ \" padUp \" ] ) parser . add_argument ( \" --padDown \" , type = size , default = False , help = help_d [ \" padDown \" ] ) parser . add_argument ( \" --padLeft \" , type = size , default = False , help = help_d [ \" padLeft \" ] ) parser . add_argument ( \" --padRight \" , type = size , default = False , help = help_d [ \" padRight \" ] ) parser . add_argument ( \" --facePercent \" , type = size , default = 50 , help = help_d [ \" facePercent \" ] ) return parser . parse_args () reject def ( input_filename , reject_filename ) Move the input file to the reject location. View Source def reject ( input_filename , reject_filename ) : \"\"\" Move the input file to the reject location. \"\"\" if input_filename != reject_filename : # Move the file to the reject directory shutil . move ( input_filename , reject_filename ) size def ( i ) Returns valid only if input is a positive integer under 1e5 View Source def size ( i ) : \"\"\" Returns valid only if input is a positive integer under 1e5 \"\"\" error = \" Invalid pixel size \" try : i = int ( i ) except TypeError : raise argparse . ArgumentTypeError ( error ) if i > 0 and i < 1 e5 : return i else : raise argparse . ArgumentTypeError ( error ) Classes ImageReadError class ( * args , ** kwargs ) Common base class for all exceptions Ancestors (in MRO) builtins.BaseException View Source class ImageReadError ( BaseException ): pass","title":"Autocrop"},{"location":"reference/autocrop/autocrop/#module-autocropautocrop","text":"View Source # -*- coding: utf-8 -*- from __future__ import print_function import argparse import cv2 import io import numpy as np import os import shutil import sys from PIL import Image from .__version__ import __version__ from .constants import ( FIXEXP , MINFACE , GAMMA_THRES , GAMMA , QUESTION_OVERWRITE , CV2_FILETYPES , PILLOW_FILETYPES , CASCFILE , ) COMBINED_FILETYPES = CV2_FILETYPES + PILLOW_FILETYPES INPUT_FILETYPES = COMBINED_FILETYPES + [ s . upper () for s in COMBINED_FILETYPES ] # Load XML Resource d = os . path . dirname ( sys . modules [ \"autocrop\" ] . __file__ ) cascPath = os . path . join ( d , CASCFILE ) # Load custom exception to catch a certain failure type class ImageReadError ( BaseException ): pass # Define simple gamma correction fn def gamma ( img , correction ): img = cv2 . pow ( img / 255.0 , correction ) return np . uint8 ( img * 255 ) def crop_positions ( imgh , imgw , x , y , w , h , fheight , fwidth , facePercent , padUp , padDown , padLeft , padRight , ): # Check padding values padUp = 50 if ( padUp is False or padUp < 0 ) else padUp padDown = 50 if ( padDown is False or padDown < 0 ) else padDown padLeft = 50 if ( padLeft is False or padLeft < 0 ) else padLeft padRight = 50 if ( padRight is False or padRight < 0 ) else padRight # enfoce face percent facePercent = 100 if facePercent > 100 else facePercent facePercent = 50 if facePercent <= 0 else facePercent # Adjust output height based on Face percent height_crop = h * 100.0 / facePercent # Ensure height is within boundaries height_crop = imgh if height_crop > imgh else height_crop aspect_ratio = float ( fwidth ) / float ( fheight ) # Calculate width based on aspect ratio width_crop = aspect_ratio * float ( height_crop ) # Calculate padding by centering face xpad = ( width_crop - w ) / 2 ypad = ( height_crop - h ) / 2 # Calc. positions of crop h1 = float ( x - ( xpad * padLeft / ( padLeft + padRight ))) h2 = float ( x + w + ( xpad * padRight / ( padLeft + padRight ))) v1 = float ( y - ( ypad * padUp / ( padUp + padDown ))) v2 = float ( y + h + ( ypad * padDown / ( padUp + padDown ))) # Move crop inside photo boundaries while h1 < 0 : h1 = h1 + 1 h2 = h2 + 1 while v1 < 0 : v1 = v1 + 1 v2 = v2 + 1 while v2 > imgh : v2 = v2 - 1 h2 = h2 - 1 * aspect_ratio while h2 > imgw : h2 = h2 - 1 v2 = v2 - 1 / aspect_ratio return [ int ( v1 ), int ( v2 ), int ( h1 ), int ( h2 )] def crop ( image , fheight = 500 , fwidth = 500 , facePercent = 50 , padUp = False , padDown = False , padLeft = False , padRight = False , ): \"\"\"Given a ndarray image with a face, returns cropped array. Arguments: - image, the numpy array of the image to be processed. - fwidth, the final width (px) of the cropped img. Default: 500 - fheight, the final height (px) of the cropped img. Default: 500 - facePercent, percentage of face height to image height. Default: 50 - padUp, Padding from top - padDown, Padding to bottom - padLeft, Padding from left - padRight, Padding to right Returns: - image, a cropped numpy array ndarray, int, int -> ndarray \"\"\" # Some grayscale color profiles can throw errors, catch them try : gray = cv2 . cvtColor ( image , cv2 . COLOR_BGR2GRAY ) except cv2 . error : gray = image # Scale the image try : height , width = image . shape [: 2 ] except AttributeError : raise ImageReadError minface = int ( np . sqrt ( height ** 2 + width ** 2 ) / MINFACE ) # Create the haar cascade faceCascade = cv2 . CascadeClassifier ( cascPath ) # ====== Detect faces in the image ====== faces = faceCascade . detectMultiScale ( gray , scaleFactor = 1.1 , minNeighbors = 5 , minSize = ( minface , minface ), flags = cv2 . CASCADE_FIND_BIGGEST_OBJECT | cv2 . CASCADE_DO_ROUGH_SEARCH , ) # Handle no faces if len ( faces ) == 0 : return None # Make padding from biggest face found x , y , w , h = faces [ - 1 ] pos = crop_positions ( height , width , x , y , w , h , fheight , fwidth , facePercent , padUp , padDown , padLeft , padRight , ) # Actual cropping image = image [ pos [ 0 ]: pos [ 1 ], pos [ 2 ]: pos [ 3 ]] # Resize image = cv2 . resize ( image , ( fwidth , fheight ), interpolation = cv2 . INTER_AREA ) # ====== Dealing with underexposition ====== if FIXEXP : # Check if under-exposed uexp = cv2 . calcHist ([ gray ], [ 0 ], None , [ 256 ], [ 0 , 256 ]) if sum ( uexp [ - 26 :]) < GAMMA_THRES * sum ( uexp ): image = gamma ( image , GAMMA ) return image def open_file ( input_filename ): \"\"\"Given a filename, returns a numpy array\"\"\" extension = os . path . splitext ( input_filename )[ 1 ] . lower () if extension in CV2_FILETYPES : # Try with cv2 return cv2 . imread ( input_filename ) if extension in PILLOW_FILETYPES : # Try with PIL with Image . open ( input_filename ) as img_orig : return np . asarray ( img_orig ) return None def output ( input_filename , output_filename , image ): \"\"\"Move the input file to the output location and write over it with the cropped image data.\"\"\" if input_filename != output_filename : # Move the file to the output directory shutil . move ( input_filename , output_filename ) # Encode the image as an in-memory PNG img_png = cv2 . imencode ( \".png\" , image )[ 1 ] . tostring () # Read the PNG data img_new = Image . open ( io . BytesIO ( img_png )) # Write the new image (converting the format to match the output # filename if necessary) img_new . save ( output_filename ) def reject ( input_filename , reject_filename ): \"\"\"Move the input file to the reject location.\"\"\" if input_filename != reject_filename : # Move the file to the reject directory shutil . move ( input_filename , reject_filename ) def main ( input_d , output_d , reject_d , fheight = 500 , fwidth = 500 , facePercent = 50 , padUp = False , padDown = False , padLeft = False , padRight = False , ): \"\"\"Crops folder of images to the desired height and width if a face is found If input_d == output_d or output_d is None, overwrites all files where the biggest face was found. Args: input_d (str): Directory to crop images from. output_d (str): Directory where cropped images are placed. reject_d (str): Directory where images that cannot be cropped are placed. fheight (int): Height (px) to which to crop the image. Default: 500px fwidth (int): Width (px) to which to crop the image. Default: 500px facePercent (int) : Percentage of face from height, Default: 50 Side Effects: Creates image files in output directory. str, str, (int), (int) -> None \"\"\" reject_count = 0 output_count = 0 input_files = [ os . path . join ( input_d , f ) for f in os . listdir ( input_d ) if any ( f . endswith ( t ) for t in INPUT_FILETYPES ) ] if output_d is None : output_d = input_d if reject_d is None and output_d is None : reject_d = input_d if reject_d is None : reject_d = output_d # Guard against calling the function directly input_count = len ( input_files ) assert input_count > 0 # Main loop for input_filename in input_files : basename = os . path . basename ( input_filename ) output_filename = os . path . join ( output_d , basename ) reject_filename = os . path . join ( reject_d , basename ) input_img = open_file ( input_filename ) image = None # Attempt the crop try : image = crop ( input_img , fheight , fwidth , facePercent , padUp , padDown , padLeft , padRight , ) except ImageReadError : print ( \"Read error: {}\" . format ( input_filename )) continue # Did the crop produce an invalid image? if isinstance ( image , type ( None )): reject ( input_filename , reject_filename ) print ( \"No face detected: {}\" . format ( reject_filename )) reject_count += 1 else : output ( input_filename , output_filename , image ) print ( \"Face detected: {}\" . format ( output_filename )) output_count += 1 # Stop and print status print ( \"{} input files, {} faces cropped, {} rejected\" . format ( input_count , output_count , reject_count ) ) def input_path ( p ): \"\"\"Returns path, only if input is a valid directory\"\"\" no_folder = \"Input folder does not exist\" no_images = \"Input folder does not contain any image files\" p = os . path . abspath ( p ) if not os . path . isdir ( p ): raise argparse . ArgumentTypeError ( no_folder ) filetypes = set ( os . path . splitext ( f )[ - 1 ] for f in os . listdir ( p )) if not any ( t in INPUT_FILETYPES for t in filetypes ): raise argparse . ArgumentTypeError ( no_images ) else : return p def output_path ( p ): \"\"\"Returns path, if input is a valid directory name. If directory doesn't exist, creates it.\"\"\" p = os . path . abspath ( p ) if not os . path . isdir ( p ): os . makedirs ( p ) return p def size ( i ): \"\"\"Returns valid only if input is a positive integer under 1e5\"\"\" error = \"Invalid pixel size\" try : i = int ( i ) except TypeError : raise argparse . ArgumentTypeError ( error ) if i > 0 and i < 1e5 : return i else : raise argparse . ArgumentTypeError ( error ) def compat_input ( s = \"\" ): \"\"\"Compatibility function to permit testing for Python 2 and 3\"\"\" try : return raw_input ( s ) except NameError : # Py2 raw_input() renamed to input() in Py3 return input ( s ) # lgtm[py/use-of-input] def confirmation ( question , default = True ): \"\"\"Ask a yes/no question via standard input and return the answer. If invalid input is given, the user will be asked until they acutally give valid input. Args: question(str): A question that is presented to the user. default(bool|None): The default value when enter is pressed with no value. When None, there is no default value and the query will loop. Returns: A bool indicating whether user has entered yes or no. Side Effects: Blocks program execution until valid input(y/n) is given. \"\"\" yes_list = [ \"yes\" , \"y\" ] no_list = [ \"no\" , \"n\" ] default_dict = { # default => prompt default string None : \"[y/n]\" , True : \"[Y]/n\" , False : \"y/[N]\" , } default_str = default_dict [ default ] prompt_str = \" %s %s \" % ( question , default_str ) while True : choice = compat_input ( prompt_str ) . lower () if not choice and default is not None : return default if choice in yes_list : return True if choice in no_list : return False notification_str = \"Please respond with 'y' or 'n'\" print ( notification_str ) def parse_args ( args ): help_d = { \"desc\" : \"Automatically crops faces from batches of pictures\" , \"input\" : \"\"\"Folder where images to crop are located. Default: current working directory\"\"\" , \"output\" : \"\"\"Folder where cropped images will be moved to. Default: current working directory, meaning images are cropped in place.\"\"\" , \"reject\" : \"\"\"Folder where images that could not be cropped will be moved to. Default: current working directory, meaning images that are not cropped will be left in place.\"\"\" , \"width\" : \"Width of cropped files in px. Default=500\" , \"height\" : \"Height of cropped files in px. Default=500\" , \"y\" : \"Bypass any confirmation prompts\" , \"facePercent\" : \"Percentage of face to image height\" , \"padUp\" : \"Add padding up to face cropped\" , \"padDown\" : \"Add padding down to face cropped\" , \"padLeft\" : \"Add padding left to face cropped\" , \"padRight\" : \"Add padding right to face cropped\" , } parser = argparse . ArgumentParser ( description = help_d [ \"desc\" ]) parser . add_argument ( \"-i\" , \"--input\" , default = \".\" , type = input_path , help = help_d [ \"input\" ] ) parser . add_argument ( \"-o\" , \"--output\" , \"-p\" , \"--path\" , type = output_path , default = None , help = help_d [ \"output\" ], ) parser . add_argument ( \"-r\" , \"--reject\" , type = output_path , default = None , help = help_d [ \"reject\" ] ) parser . add_argument ( \"-w\" , \"--width\" , type = size , default = 500 , help = help_d [ \"width\" ] ) parser . add_argument ( \"-H\" , \"--height\" , type = size , default = 500 , help = help_d [ \"height\" ] ) parser . add_argument ( \"-v\" , \"--version\" , action = \"version\" , version = \" %(prog)s version {}\" . format ( __version__ ), ) parser . add_argument ( \"--no-confirm\" , action = \"store_true\" , help = help_d [ \"y\" ]) parser . add_argument ( \"--padUp\" , type = size , default = False , help = help_d [ \"padUp\" ] ) parser . add_argument ( \"--padDown\" , type = size , default = False , help = help_d [ \"padDown\" ] ) parser . add_argument ( \"--padLeft\" , type = size , default = False , help = help_d [ \"padLeft\" ] ) parser . add_argument ( \"--padRight\" , type = size , default = False , help = help_d [ \"padRight\" ] ) parser . add_argument ( \"--facePercent\" , type = size , default = 50 , help = help_d [ \"facePercent\" ] ) return parser . parse_args () def cli (): args = parse_args ( sys . argv [ 1 :]) if not args . no_confirm : if args . output is None or args . input == args . output : if not confirmation ( QUESTION_OVERWRITE ): sys . exit () if args . input == args . output : args . output = None print ( \"Processing images in folder:\" , args . input ) main ( args . input , args . output , args . reject , args . height , args . width , args . facePercent , args . padUp , args . padDown , args . padLeft , args . padRight , )","title":"Module autocrop.autocrop"},{"location":"reference/autocrop/autocrop/#functions","text":"","title":"Functions"},{"location":"reference/autocrop/autocrop/#cli","text":"def ( ) View Source def cli () : args = parse_args ( sys . argv [ 1 :] ) if not args . no_confirm : if args . output is None or args . input == args . output : if not confirmation ( QUESTION_OVERWRITE ) : sys . exit () if args . input == args . output : args . output = None print ( \" Processing images in folder: \" , args . input ) main ( args . input , args . output , args . reject , args . height , args . width , args . facePercent , args . padUp , args . padDown , args . padLeft , args . padRight , )","title":"cli"},{"location":"reference/autocrop/autocrop/#compat_input","text":"def ( s = '' ) Compatibility function to permit testing for Python 2 and 3 View Source def compat_input ( s = \"\" ) : \"\"\" Compatibility function to permit testing for Python 2 and 3 \"\"\" try : return raw_input ( s ) except NameError : # Py2 raw_input () renamed to input () in Py3 return input ( s ) # lgtm [ py / use - of - input ]","title":"compat_input"},{"location":"reference/autocrop/autocrop/#confirmation","text":"def ( question , default = True ) Ask a yes/no question via standard input and return the answer. If invalid input is given, the user will be asked until they acutally give valid input. Args: question(str): A question that is presented to the user. default(bool|None): The default value when enter is pressed with no value. When None, there is no default value and the query will loop. Returns: A bool indicating whether user has entered yes or no. Side Effects: Blocks program execution until valid input(y/n) is given. View Source def confirmation ( question , default = True ) : \"\"\" Ask a yes/no question via standard input and return the answer. If invalid input is given , the user will be asked until they acutally give valid input . Args : question ( str ) : A question that is presented to the user . default ( bool | None ) : The default value when enter is pressed with no value . When None , there is no default value and the query will loop . Returns : A bool indicating whether user has entered yes or no . Side Effects : Blocks program execution until valid input ( y / n ) is given . \"\"\" yes_list = [ \" yes \" , \" y \" ] no_list = [ \" no \" , \" n \" ] default_dict = { # default => prompt default string None : \" [y/n] \" , True : \" [Y]/n \" , False : \" y/[N] \" , } default_str = default_dict [ default ] prompt_str = \" %s %s \" % ( question , default_str ) while True : choice = compat_input ( prompt_str ) . lower () if not choice and default is not None : return default if choice in yes_list : return True if choice in no_list : return False notification_str = \" Please respond with 'y' or 'n' \" print ( notification_str )","title":"confirmation"},{"location":"reference/autocrop/autocrop/#crop","text":"def ( image , fheight = 500 , fwidth = 500 , facePercent = 50 , padUp = False , padDown = False , padLeft = False , padRight = False ) Given a ndarray image with a face, returns cropped array. Arguments: - image, the numpy array of the image to be processed. - fwidth, the final width (px) of the cropped img. Default: 500 - fheight, the final height (px) of the cropped img. Default: 500 - facePercent, percentage of face height to image height. Default: 50 - padUp, Padding from top - padDown, Padding to bottom - padLeft, Padding from left - padRight, Padding to right Returns: - image, a cropped numpy array ndarray, int, int -> ndarray View Source def crop ( image , fheight = 500 , fwidth = 500 , facePercent = 50 , padUp = False , padDown = False , padLeft = False , padRight = False , ) : \"\"\" Given a ndarray image with a face, returns cropped array. Arguments : - image , the numpy array of the image to be processed . - fwidth , the final width ( px ) of the cropped img . Default : 500 - fheight , the final height ( px ) of the cropped img . Default : 500 - facePercent , percentage of face height to image height . Default : 50 - padUp , Padding from top - padDown , Padding to bottom - padLeft , Padding from left - padRight , Padding to right Returns : - image , a cropped numpy array ndarray , int , int -> ndarray \"\"\" # Some grayscale color profiles can throw errors , catch them try : gray = cv2 . cvtColor ( image , cv2 . COLOR_BGR2GRAY ) except cv2 . error : gray = image # Scale the image try : height , width = image . shape [: 2 ] except AttributeError : raise ImageReadError minface = int ( np . sqrt ( height ** 2 + width ** 2 ) / MINFACE ) # Create the haar cascade faceCascade = cv2 . CascadeClassifier ( cascPath ) # ====== Detect faces in the image ====== faces = faceCascade . detectMultiScale ( gray , scaleFactor = 1 . 1 , minNeighbors = 5 , minSize = ( minface , minface ) , flags = cv2 . CASCADE_FIND_BIGGEST_OBJECT | cv2 . CASCADE_DO_ROUGH_SEARCH , ) # Handle no faces if len ( faces ) == 0 : return None # Make padding from biggest face found x , y , w , h = faces [ - 1 ] pos = crop_positions ( height , width , x , y , w , h , fheight , fwidth , facePercent , padUp , padDown , padLeft , padRight , ) # Actual cropping image = image [ pos [ 0 ]: pos [ 1 ], pos [ 2 ]: pos [ 3 ]] # Resize image = cv2 . resize ( image , ( fwidth , fheight ) , interpolation = cv2 . INTER_AREA ) # ====== Dealing with underexposition ====== if FIXEXP : # Check if under - exposed uexp = cv2 . calcHist ( [ gray ], [ 0 ], None , [ 256 ], [ 0 , 256 ] ) if sum ( uexp [ - 26 :] ) < GAMMA_THRES * sum ( uexp ) : image = gamma ( image , GAMMA ) return image","title":"crop"},{"location":"reference/autocrop/autocrop/#crop_positions","text":"def ( imgh , imgw , x , y , w , h , fheight , fwidth , facePercent , padUp , padDown , padLeft , padRight ) View Source def crop_positions ( imgh , imgw , x , y , w , h , fheight , fwidth , facePercent , padUp , padDown , padLeft , padRight , ) : # Check padding values padUp = 50 if ( padUp is False or padUp < 0 ) else padUp padDown = 50 if ( padDown is False or padDown < 0 ) else padDown padLeft = 50 if ( padLeft is False or padLeft < 0 ) else padLeft padRight = 50 if ( padRight is False or padRight < 0 ) else padRight # enfoce face percent facePercent = 100 if facePercent > 100 else facePercent facePercent = 50 if facePercent <= 0 else facePercent # Adjust output height based on Face percent height_crop = h * 100 . 0 / facePercent # Ensure height is within boundaries height_crop = imgh if height_crop > imgh else height_crop aspect_ratio = float ( fwidth ) / float ( fheight ) # Calculate width based on aspect ratio width_crop = aspect_ratio * float ( height_crop ) # Calculate padding by centering face xpad = ( width_crop - w ) / 2 ypad = ( height_crop - h ) / 2 # Calc . positions of crop h1 = float ( x - ( xpad * padLeft / ( padLeft + padRight ))) h2 = float ( x + w + ( xpad * padRight / ( padLeft + padRight ))) v1 = float ( y - ( ypad * padUp / ( padUp + padDown ))) v2 = float ( y + h + ( ypad * padDown / ( padUp + padDown ))) # Move crop inside photo boundaries while h1 < 0 : h1 = h1 + 1 h2 = h2 + 1 while v1 < 0 : v1 = v1 + 1 v2 = v2 + 1 while v2 > imgh : v2 = v2 - 1 h2 = h2 - 1 * aspect_ratio while h2 > imgw : h2 = h2 - 1 v2 = v2 - 1 / aspect_ratio return [ int ( v1 ) , int ( v2 ) , int ( h1 ) , int ( h2 ) ]","title":"crop_positions"},{"location":"reference/autocrop/autocrop/#gamma","text":"def ( img , correction ) View Source def gamma ( img , correction ) : img = cv2 . pow ( img / 255 . 0 , correction ) return np . uint8 ( img * 255 )","title":"gamma"},{"location":"reference/autocrop/autocrop/#input_path","text":"def ( p ) Returns path, only if input is a valid directory View Source def input_path ( p ) : \"\"\" Returns path, only if input is a valid directory \"\"\" no_folder = \" Input folder does not exist \" no_images = \" Input folder does not contain any image files \" p = os . path . abspath ( p ) if not os . path . isdir ( p ) : raise argparse . ArgumentTypeError ( no_folder ) filetypes = set ( os . path . splitext ( f ) [ - 1 ] for f in os . listdir ( p )) if not any ( t in INPUT_FILETYPES for t in filetypes ) : raise argparse . ArgumentTypeError ( no_images ) else : return p","title":"input_path"},{"location":"reference/autocrop/autocrop/#main","text":"def ( input_d , output_d , reject_d , fheight = 500 , fwidth = 500 , facePercent = 50 , padUp = False , padDown = False , padLeft = False , padRight = False ) Crops folder of images to the desired height and width if a face is found If input_d == output_d or output_d is None, overwrites all files where the biggest face was found. Args: input_d (str): Directory to crop images from. output_d (str): Directory where cropped images are placed. reject_d (str): Directory where images that cannot be cropped are placed. fheight (int): Height (px) to which to crop the image. Default: 500px fwidth (int): Width (px) to which to crop the image. Default: 500px facePercent (int) : Percentage of face from height, Default: 50 Side Effects: Creates image files in output directory. str, str, (int), (int) -> None View Source def main ( input_d , output_d , reject_d , fheight = 500 , fwidth = 500 , facePercent = 50 , padUp = False , padDown = False , padLeft = False , padRight = False , ) : \"\"\" Crops folder of images to the desired height and width if a face is found If input_d == output_d or output_d is None , overwrites all files where the biggest face was found . Args : input_d ( str ) : Directory to crop images from . output_d ( str ) : Directory where cropped images are placed . reject_d ( str ) : Directory where images that cannot be cropped are placed . fheight ( int ) : Height ( px ) to which to crop the image . Default : 500 px fwidth ( int ) : Width ( px ) to which to crop the image . Default : 500 px facePercent ( int ) : Percentage of face from height , Default : 50 Side Effects : Creates image files in output directory . str , str , ( int ) , ( int ) -> None \"\"\" reject_count = 0 output_count = 0 input_files = [ os . path . join ( input_d , f ) for f in os . listdir ( input_d ) if any ( f . endswith ( t ) for t in INPUT_FILETYPES ) ] if output_d is None : output_d = input_d if reject_d is None and output_d is None : reject_d = input_d if reject_d is None : reject_d = output_d # Guard against calling the function directly input_count = len ( input_files ) assert input_count > 0 # Main loop for input_filename in input_files : basename = os . path . basename ( input_filename ) output_filename = os . path . join ( output_d , basename ) reject_filename = os . path . join ( reject_d , basename ) input_img = open_file ( input_filename ) image = None # Attempt the crop try : image = crop ( input_img , fheight , fwidth , facePercent , padUp , padDown , padLeft , padRight , ) except ImageReadError : print ( \" Read error: {} \" . format ( input_filename )) continue # Did the crop produce an invalid image ? if isinstance ( image , type ( None )) : reject ( input_filename , reject_filename ) print ( \" No face detected: {} \" . format ( reject_filename )) reject_count += 1 else : output ( input_filename , output_filename , image ) print ( \" Face detected: {} \" . format ( output_filename )) output_count += 1 # Stop and print status print ( \" {} input files, {} faces cropped, {} rejected \" . format ( input_count , output_count , reject_count ) )","title":"main"},{"location":"reference/autocrop/autocrop/#open_file","text":"def ( input_filename ) Given a filename, returns a numpy array View Source def open_file ( input_filename ) : \"\"\" Given a filename, returns a numpy array \"\"\" extension = os . path . splitext ( input_filename ) [ 1 ]. lower () if extension in CV2_FILETYPES : # Try with cv2 return cv2 . imread ( input_filename ) if extension in PILLOW_FILETYPES : # Try with PIL with Image . open ( input_filename ) as img_orig : return np . asarray ( img_orig ) return None","title":"open_file"},{"location":"reference/autocrop/autocrop/#output","text":"def ( input_filename , output_filename , image ) Move the input file to the output location and write over it with the cropped image data. View Source def output ( input_filename , output_filename , image ) : \"\"\" Move the input file to the output location and write over it with the cropped image data . \"\"\" if input_filename != output_filename : # Move the file to the output directory shutil . move ( input_filename , output_filename ) # Encode the image as an in - memory PNG img_png = cv2 . imencode ( \" .png \" , image ) [ 1 ]. tostring () # Read the PNG data img_new = Image . open ( io . BytesIO ( img_png )) # Write the new image ( converting the format to match the output # filename if necessary ) img_new . save ( output_filename )","title":"output"},{"location":"reference/autocrop/autocrop/#output_path","text":"def ( p ) Returns path, if input is a valid directory name. If directory doesn't exist, creates it. View Source def output_path ( p ) : \"\"\" Returns path, if input is a valid directory name. If directory doesn ' t exist, creates it.\"\"\" p = os . path . abspath ( p ) if not os . path . isdir ( p ) : os . makedirs ( p ) return p","title":"output_path"},{"location":"reference/autocrop/autocrop/#parse_args","text":"def ( args ) View Source def parse_args ( args ) : help_d = { \" desc \" : \" Automatically crops faces from batches of pictures \" , \" input \" : \"\"\" Folder where images to crop are located. Default: current working directory \"\"\" , \" output \" : \"\"\" Folder where cropped images will be moved to. Default : current working directory , meaning images are cropped in place . \"\"\" , \" reject \" : \"\"\" Folder where images that could not be cropped will be moved to . Default : current working directory , meaning images that are not cropped will be left in place . \"\"\" , \" width \" : \" Width of cropped files in px. Default=500 \" , \" height \" : \" Height of cropped files in px. Default=500 \" , \" y \" : \" Bypass any confirmation prompts \" , \" facePercent \" : \" Percentage of face to image height \" , \" padUp \" : \" Add padding up to face cropped \" , \" padDown \" : \" Add padding down to face cropped \" , \" padLeft \" : \" Add padding left to face cropped \" , \" padRight \" : \" Add padding right to face cropped \" , } parser = argparse . ArgumentParser ( description = help_d [ \" desc \" ] ) parser . add_argument ( \" -i \" , \" --input \" , default = \" . \" , type = input_path , help = help_d [ \" input \" ] ) parser . add_argument ( \" -o \" , \" --output \" , \" -p \" , \" --path \" , type = output_path , default = None , help = help_d [ \" output \" ], ) parser . add_argument ( \" -r \" , \" --reject \" , type = output_path , default = None , help = help_d [ \" reject \" ] ) parser . add_argument ( \" -w \" , \" --width \" , type = size , default = 500 , help = help_d [ \" width \" ] ) parser . add_argument ( \" -H \" , \" --height \" , type = size , default = 500 , help = help_d [ \" height \" ] ) parser . add_argument ( \" -v \" , \" --version \" , action = \" version \" , version = \" %(prog)s version {} \" . format ( __version__ ) , ) parser . add_argument ( \" --no-confirm \" , action = \" store_true \" , help = help_d [ \" y \" ] ) parser . add_argument ( \" --padUp \" , type = size , default = False , help = help_d [ \" padUp \" ] ) parser . add_argument ( \" --padDown \" , type = size , default = False , help = help_d [ \" padDown \" ] ) parser . add_argument ( \" --padLeft \" , type = size , default = False , help = help_d [ \" padLeft \" ] ) parser . add_argument ( \" --padRight \" , type = size , default = False , help = help_d [ \" padRight \" ] ) parser . add_argument ( \" --facePercent \" , type = size , default = 50 , help = help_d [ \" facePercent \" ] ) return parser . parse_args ()","title":"parse_args"},{"location":"reference/autocrop/autocrop/#reject","text":"def ( input_filename , reject_filename ) Move the input file to the reject location. View Source def reject ( input_filename , reject_filename ) : \"\"\" Move the input file to the reject location. \"\"\" if input_filename != reject_filename : # Move the file to the reject directory shutil . move ( input_filename , reject_filename )","title":"reject"},{"location":"reference/autocrop/autocrop/#size","text":"def ( i ) Returns valid only if input is a positive integer under 1e5 View Source def size ( i ) : \"\"\" Returns valid only if input is a positive integer under 1e5 \"\"\" error = \" Invalid pixel size \" try : i = int ( i ) except TypeError : raise argparse . ArgumentTypeError ( error ) if i > 0 and i < 1 e5 : return i else : raise argparse . ArgumentTypeError ( error )","title":"size"},{"location":"reference/autocrop/autocrop/#classes","text":"","title":"Classes"},{"location":"reference/autocrop/autocrop/#imagereaderror","text":"class ( * args , ** kwargs ) Common base class for all exceptions","title":"ImageReadError"},{"location":"reference/autocrop/autocrop/#ancestors-in-mro","text":"builtins.BaseException View Source class ImageReadError ( BaseException ): pass","title":"Ancestors (in MRO)"},{"location":"reference/autocrop/constants/","text":"Module autocrop.constants View Source # -*- coding : utf - 8 -*- FIXEXP = True # Flag to fix underexposition MINFACE = 8 # Minimum face size ratio ; too low and we get false positives INCREMENT = 0 . 06 GAMMA_THRES = 0 . 001 GAMMA = 0 . 90 FACE_RATIO = 6 # Face / padding ratio QUESTION_OVERWRITE = \"Overwrite image files?\" # File types supported by OpenCV CV2_FILETYPES = [ \".bmp\" , \".dib\" , \".jp2\" , \".jpe\" , \".jpeg\" , \".jpg\" , \".pbm\" , \".pgm\" , \".png\" , \".ppm\" , \".ras\" , \".sr\" , \".tif\" , \".tiff\" , \".webp\" , ] # File types supported by Pillow PILLOW_FILETYPES = [ \".eps\" , \".gif\" , \".icns\" , \".ico\" , \".im\" , \".msp\" , \".pcx\" , \".sgi\" , \".spi\" , \".xbm\" , ] CASCFILE = \"haarcascade_frontalface_default.xml\"","title":"Constants"},{"location":"reference/autocrop/constants/#module-autocropconstants","text":"View Source # -*- coding : utf - 8 -*- FIXEXP = True # Flag to fix underexposition MINFACE = 8 # Minimum face size ratio ; too low and we get false positives INCREMENT = 0 . 06 GAMMA_THRES = 0 . 001 GAMMA = 0 . 90 FACE_RATIO = 6 # Face / padding ratio QUESTION_OVERWRITE = \"Overwrite image files?\" # File types supported by OpenCV CV2_FILETYPES = [ \".bmp\" , \".dib\" , \".jp2\" , \".jpe\" , \".jpeg\" , \".jpg\" , \".pbm\" , \".pgm\" , \".png\" , \".ppm\" , \".ras\" , \".sr\" , \".tif\" , \".tiff\" , \".webp\" , ] # File types supported by Pillow PILLOW_FILETYPES = [ \".eps\" , \".gif\" , \".icns\" , \".ico\" , \".im\" , \".msp\" , \".pcx\" , \".sgi\" , \".spi\" , \".xbm\" , ] CASCFILE = \"haarcascade_frontalface_default.xml\"","title":"Module autocrop.constants"},{"location":"tests/data/","text":"Testing images All these images were found on Wikimedia, marked as Public Domain. -Fran\u00e7ois Leblanc, 2018","title":"Testing images"},{"location":"tests/data/#testing-images","text":"All these images were found on Wikimedia, marked as Public Domain. -Fran\u00e7ois Leblanc, 2018","title":"Testing images"}]}